# Preface {.unnumbered}

> "Any application that can be written in JavaScript, will eventually be written in JavaScript."
> -- Jeff Atwood *(a.k.a. Atwood’s Law)*

For this wiki, we will be using **React** (JavaScript Library) for the user-interface layer and **Tailwind CSS** for styling. You can think of React as a declaritive "state -> UI" engine. Rather than issuing step-by-step DOM (Document Object Model) commands ("create a `<div>`, set a text, append it here..."), you instead describe what the interface should look like for a given state. Here is essentially what React does:

1. Builds an in-memory snapshot of the UI (the virtual DOM).
2. Diffs it against the previous snapshot.
3. Applies only the minimal DOM changes needed.

This approach lets you treat each piece as an independent, reusable component. Each component recieves data (state) and React handles the rest. Here is an example of an implementation with HTML + Javascript and React.

*HTML + Javascript*
```Javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Click counter</title>
  <style>
    button { font-size: 1rem; padding: 0.5rem 1rem; }
    p      { font-family: sans-serif; }
  </style>
</head>
<body>
  <p>You clicked <span id="count">0</span> times.</p>
  <button id="btn">Click me</button>

  <script>
    // grab elements
    const btn   = document.getElementById('btn');
    const count = document.getElementById('count');
    let clicks  = 0;

    // attach event listener
    btn.addEventListener('click', () => {
      clicks += 1;          // update state
      count.textContent = clicks; // update DOM manually
    });
  </script>
</body>
</html>
```
*How it works?*

1. You manipulate the DOM directly (`getElementById`, `.textContent`). 
2. State (`clicks`) lives outside the DOM and must stay in sync by hand.

```javascript
// DOM manipulation

    btn.addEventListener('click', () => {
      clicks += 1;          // update state
      count.textContent = clicks; // update DOM manually
    });
```

*React*
```Javascript
// index.html
<body>
  <div id="root"></div>
  <script type="module" src="/src/index.jsx"></script>
</body>

// src/index.jsx
import { useState } from "react";

export default function Counter() {
  const [clicks, setClicks] = useState(0);

  return (
    <div>
      <p>You clicked {clicks} times.</p>
      <button onClick={() => setClicks(clicks + 1)}>
        Click me
      </button>
    </div>
  );
}

createRoot(document.getElementById("root")).render(<Counter />);
```
*What changed?*

1. The `click` return variable becomes a declaritive description of what the UI (user interface) should look like in its current state. 
2. Calling `setClicks` triggers React’s diff-and-patch cycle, turning the new description into the actual DOM.
3. IMPORTANT: you could drop `<Counter />` in multiple places and each gets isolated state (make multiple, independent copies).

Tailwind CSS, in turn, gives you a bunch of utility classes (`flex`, `bg-indigo-500`, `p-4`, `rounded-lg`), which are essentially predefined CSS rules that tailwind ships for you. Instead of having to write CSS files from scratch, you have "pre-made CSS" building blocks. Here is a comparison if you were to write them both in a CSS file:

*Tailwind*
```css
.my-element {
    @apply flex bg-blue-600 text-white p-4 rounded-lg;
}
```

*Normal CSS*
```css
.my-element {
  display: flex;
  background-color: #2563eb;
  color: #ffffff;
  padding: 1rem;                 /* p-4 */
  border-radius: 0.5rem;         /* rounded-lg */
}
```

As you can see, Tailwind essentially streamlines and make the code less-verbose.

::: {.tree-box}
```text
/📂 src
   ├─ 📂 components   # Shared React components
   ├─ 📂 pages        # Top-level wiki pages
   ├─ 📂 styles       # Tailwind config & global styles
   └─ 📂 assets       # Images, icons, and other static files
/📂 public            # Compiled output served by the wiki host
```
*Note:* Standard directory for reference (not wiki directory).

# Timeline

🚀 Current timeline for completing wiki: **June 16 -- September 14, 2025**.

0. **Week 0 ( -- June 16)**
   - [ ] Setup Github repository

1. **Week 1 (June 16 -- June 22)**  
   
   - [ ] *Plan:* outline wiki information architecture
   - [ ] Agree on style guide (colors, typography, nav)
   - [ ] Workshops on JavaScript, HTML, React + Tailwind
   - [ ] Outline wiki design on Figma.

2. **Week 2 (June 23 -- June 29)**  

   - [ ] Outline wiki design on Figma (continue)
   - [ ] Build landing‐page layout in React  
   - [ ] Configure Tailwind & global styles  

3. **Week 3 (June 30 -- July 6)**  

   - [ ] Implement main nav & footer components
   - [ ] Draft "Home" and "Team" page

4. **Week 4 (July 7 -- July 13)**  

   - [ ] Draft "Home" and "Team" page (continue)

5. **Week 5 (July 14 -- July 20)**  

   - [ ] Draft "Human Practices" page (continue)
   - [ ] Collect initial lab notebook entries

6. **Week 6 (July 21 -- July 27)**  

   - [ ] Draft "Human Practices" page (continue)

7. **Week 7 (July 28 -- August 3)**  

   - [ ] Draft "Dry‑Lab" page  
   - [ ] Embed interactive diagrams (three.js) (maybe)

8. **Week 8 (August 4 -- August 10)**  

   - [ ] Draft "Dry‑Lab" page (continue)

9. **Week 9 (August 11 -- August 17)**  

   - [ ] Draft "Wet‑Lab" page

10. **Week 10 (August 18 -- August 24)**  

    - [ ] Draft "Wet‑Lab" page (continue)
    - [ ] Proofread all pages  
    - [ ] Generate PDF snapshot (if required)

11. **Week 11 (August 25 -- August 31)**  

    - [ ] Draft "Wet‑Lab" page (continue)
    - [ ] Finish References & Acknowledgments pages  

12. **Week 12 (September 1 -- September 7)**  

    - [ ] Proofread all pages.
    - [ ] Light/dark theme toggle (optional)

13. **Week 13 (September 8 -- September 14)**  

    - [ ] Submit wiki before deadline
    - [ ] Implement non-essential components
    - [ ] Celebrate 🎉

14. **Week 14, 15, etc. (September 14 -- iGEM Competition)**  
    - [ ] Add last-minute information/tweaks
    - [ ] Implement non-essential components (continue)
